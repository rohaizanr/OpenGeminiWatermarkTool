# Implementation Plan: Web Application for Watermark Removal

**Branch**: `001-web-app` | **Date**: 2025-12-25 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/001-web-app/spec.md`

**Note**: This plan is generated by the `/speckit.plan` command following the constitution-defined workflow.

## Summary

Build a web application enabling users to remove Gemini watermarks from images through an intuitive browser interface. The system consists of three components: (1) a Next.js frontend with Material Design 3 UI, Cloudflare Turnstile integration, and SSR for SEO; (2) a Python FastAPI backend that orchestrates image processing; (3) a multi-stage Docker build pipeline that compiles the C++ GeminiWatermarkTool binary and embeds it in the API container. The application supports single and batch image processing with 5-second target latency for 2MB images, ephemeral storage (1-hour max retention), and deployment to GKE (backend) + Cloudflare Pages (frontend).

## Technical Context

**Language/Version**:
- **Frontend**: TypeScript 5.3+ with Next.js 14+ (App Router for SSR)
- **Backend**: Python 3.11+ with FastAPI 0.104+
- **Build Container**: C++17 with CMake 3.21+, vcpkg for dependency management
- **Container Runtime**: Docker 24+, Docker Compose 2.20+ (dev), Kubernetes 1.28+ (prod)

**Primary Dependencies**:
- **Frontend**: Next.js, React 18, Material Web Components (Material 3), Cloudflare Turnstile SDK, Tailwind CSS (for utility classes)
- **Backend**: FastAPI, Uvicorn (ASGI server), Pillow (image validation), python-multipart (file uploads), slowapi (rate limiting), httpx (Turnstile verification)
- **Build Stage**: OpenCV 4, fmt, CLI11, spdlog (same as existing CLI tool)
- **DevOps**: Docker, Docker Compose, GitHub Actions, Terraform/Kubectl (GKE), Wrangler (Cloudflare)

**Storage**:
- **Development**: Local filesystem (tmpfs for ephemeral uploads)
- **Production**: Kubernetes emptyDir volumes (pod-local ephemeral storage)
- **No persistent storage** - all uploaded images deleted post-processing

**Testing**:
- **Frontend**: Jest + React Testing Library (unit), Playwright (E2E)
- **Backend**: pytest + pytest-asyncio (unit, integration), httpx test client (API contract tests)
- **Infrastructure**: Docker Compose smoke tests, Kubernetes readiness probes

**Target Platform**:
- **Development**: Local (macOS/Linux/Windows) with Docker Desktop
- **Production Backend**: Google Kubernetes Engine (GKE) - Linux containers on x86_64 nodes
- **Production Frontend**: Cloudflare Pages - Edge workers globally distributed

**SSR/Static Generation Strategy**:
- **Server-Side Rendering (SSR)**: Homepage (page.tsx) for dynamic metadata and SEO
- **Static Generation**: Documentation pages, legal pages (Terms, Privacy) for optimal CDN caching
- **Hybrid Approach**: Next.js App Router automatically optimizes based on data fetching patterns

**Project Type**: Web application (frontend + backend + build container)

**Performance Goals**:
- Image processing: < 5 seconds for 2MB images (p95)
- API response time: < 500ms for error responses, < 5s for successful processing
- Frontend load: LCP < 2.5s, FID < 100ms, CLS < 0.1 (Core Web Vitals)
- Throughput: 100 concurrent users without degradation
- Batch processing: 10 images in < 30 seconds

**Constraints**:
- **Memory**: 2GB RAM per backend pod (2 CPU cores)
- **Storage**: 10MB max file size per upload, 1-hour max retention (ephemeral only)
- **Rate limiting**: 10 requests/minute per IP address
- **Network**: HTTPS-only, CORS restricted to Cloudflare domains
- **Offline requirement**: Frontend must handle network failures gracefully (not offline-first PWA)

**Scale/Scope**:
- **Initial launch**: 100-1000 users/day
- **Auto-scaling**: 2-10 backend pods based on CPU/memory utilization
- **File formats**: JPG, JPEG, PNG, WebP, BMP
- **Supported watermarks**: Gemini visible watermarks only (48×48 or 96×96)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### ✅ I. Cross-Platform Performance & Determinism
**Status**: PASS  
**Compliance**: Backend uses the existing C++ GeminiWatermarkTool binary (already cross-platform deterministic). Web application adds new interface but preserves core algorithm integrity.

### ✅ II. Mathematical Correctness & Precision
**Status**: PASS  
**Compliance**: Zero changes to reverse alpha blending algorithm. Web API acts as orchestrator calling the existing proven binary.

### ✅ III. User Experience & Accessibility
**Status**: PASS  
**Compliance**: Web interface improves accessibility over CLI-only approach. Drag-and-drop workflow, mobile support, and clear error messages align with UX requirements. WCAG 2.1 AA compliance ensures accessibility.

### ✅ IV. Material Design 3 UI Standards
**Status**: PASS  
**Compliance**: Frontend explicitly designed with Material 3 components, three-step workflow per LastSnap reference, responsive layouts, and Material You theming.

### ✅ V. Dual Environment Architecture
**Status**: PASS  
**Compliance**: Development environment uses Docker Compose for local testing. Production deploys backend to GKE and frontend to Cloudflare Pages per constitution requirements.

### ✅ VI. Zero Dependencies Philosophy
**Status**: PASS (with clarification)  
**Compliance**: CLI tool remains unchanged (zero dependencies maintained). Web application is separate deployment with its own dependency management (acceptable per constitution - "Web/API Dependencies (separate from CLI)"). No changes to existing CLI binary distribution.

### ✅ VII. Security & Data Safety
**Status**: PASS  
**Compliance**: 
- Ephemeral storage (1-hour max retention)
- Rate limiting (10 req/min per IP)
- Turnstile bot protection
- HTTPS-only communication
- Input validation and sanitization
- Clear disclaimer in UI about backing up originals

**Overall Assessment**: ✅ **ALL GATES PASS** - Feature aligns with all constitutional principles. Web application extends tool's reach without compromising core principles.

## Project Structure

### Documentation (this feature)

```text
specs/001-web-app/
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0 output (/speckit.plan command)
├── data-model.md        # Phase 1 output (/speckit.plan command)
├── quickstart.md        # Phase 1 output (/speckit.plan command)
├── contracts/           # Phase 1 output (/speckit.plan command)
│   └── api.openapi.yaml # OpenAPI 3.0 spec for Python API
└── tasks.md             # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan)
```

### Source Code (repository root)

```text
web/
├── frontend/
│   ├── src/
│   │   ├── app/               # Next.js App Router pages
│   │   │   ├── page.tsx       # Homepage with upload interface
│   │   │   ├── layout.tsx     # Root layout with Material 3 theming
│   │   │   └── api/           # Next.js API routes (optional client-side helpers)
│   │   ├── components/        # React components
│   │   │   ├── UploadZone.tsx       # Drag-and-drop upload area
│   │   │   ├── ProcessingIndicator.tsx  # Material 3 progress display
│   │   │   ├── ImagePreview.tsx     # Before/after comparison slider
│   │   │   └── TurnstileWidget.tsx  # Cloudflare Turnstile integration
│   │   ├── services/          # API client for backend communication
│   │   │   └── watermarkApi.ts
│   │   ├── hooks/             # Custom React hooks
│   │   ├── styles/            # Tailwind + Material 3 theme configs
│   │   └── types/             # TypeScript type definitions
│   ├── public/                # Static assets
│   ├── tests/
│   │   ├── unit/              # Component tests (Jest + RTL)
│   │   └── e2e/               # Playwright E2E tests
│   ├── package.json
│   ├── next.config.js
│   ├── tsconfig.json
│   ├── tailwind.config.js
│   └── Dockerfile             # Production build (Cloudflare Pages uses this indirectly)
│
├── backend/
│   ├── src/
│   │   ├── main.py            # FastAPI application entry point
│   │   ├── api/
│   │   │   ├── routes.py      # API endpoint definitions
│   │   │   ├── models.py      # Pydantic request/response models
│   │   │   └── middleware.py  # Rate limiting, CORS, logging
│   │   ├── services/
│   │   │   ├── watermark_service.py  # Business logic for image processing
│   │   │   ├── turnstile_service.py  # Cloudflare Turnstile verification
│   │   │   └── file_service.py       # File upload/cleanup management
│   │   ├── core/
│   │   │   ├── config.py      # Environment configuration (dev/prod)
│   │   │   ├── logging.py     # Structured logging setup
│   │   │   └── exceptions.py  # Custom exception classes
│   │   └── utils/
│   │       ├── binary_executor.py  # Wrapper to invoke GeminiWatermarkTool binary
│   │       └── validators.py       # Image format/size validation
│   ├── tests/
│   │   ├── unit/              # pytest unit tests
│   │   ├── integration/       # API integration tests
│   │   └── contract/          # OpenAPI contract validation tests
│   ├── requirements.txt       # Python dependencies
│   ├── requirements-dev.txt   # Dev dependencies (pytest, black, mypy)
│   ├── Dockerfile             # Multi-stage build (copies binary from builder)
│   └── pyproject.toml         # Python project config (black, mypy, pytest)
│
├── build/
│   └── Dockerfile.builder     # C++ build container (CMake, vcpkg, GeminiWatermarkTool compilation)
│
├── docker-compose.yml         # Development environment orchestration
├── docker-compose.prod.yml    # Production-like local testing
│
└── deployment/
    ├── kubernetes/
    │   ├── namespace.yaml
    │   ├── deployment.yaml    # Backend deployment (GKE)
    │   ├── service.yaml       # LoadBalancer service
    │   ├── hpa.yaml           # Horizontal Pod Autoscaler (2-10 replicas)
    │   ├── configmap.yaml     # Non-sensitive config
    │   └── secret.yaml.template  # Secret template (actual secrets in GCP Secret Manager)
    ├── cloudflare/
    │   └── wrangler.toml      # Cloudflare Pages configuration
    └── terraform/             # Infrastructure as Code (optional, for GKE provisioning)
        ├── main.tf
        ├── variables.tf
        └── outputs.tf
```

**Structure Decision**: Web application structure selected. This feature adds a new `web/` directory at repository root containing isolated frontend and backend projects. The existing `src/` directory (C++ CLI tool) remains unchanged. Build container (`build/Dockerfile.builder`) compiles the C++ binary, which is then copied into the backend container. This separation ensures:
1. CLI tool remains independently buildable and distributable
2. Web application has clear boundaries for deployment (frontend → Cloudflare, backend → GKE)
3. Multi-stage Docker builds minimize final image sizes
4. Development environment uses Docker Compose for easy local testing

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

**No violations** - All constitutional principles are satisfied. This section intentionally left minimal as no complexity justifications are needed.
